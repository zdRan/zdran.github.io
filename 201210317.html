<html >
	<head>
		<meta charset="utf-8">
		
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui">
		<script src="https://cdn.jsdelivr.net/npm/vue@2.6.12/dist/vue.js"></script>
		<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
		
		<link href="https://cdn.bootcdn.net/ajax/libs/vuetify/2.6.12/vuetify.min.css" rel="stylesheet">
		<script src="https://cdn.bootcdn.net/ajax/libs/vuetify/2.0.4/vuetify.min.js"></script>
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/styles/rainbow.min.css">
		<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/highlight.min.js"></script>
		<link href="https://cdn.bootcdn.net/ajax/libs/MaterialDesign-Webfont/6.9.96/css/materialdesignicons.min.css" rel="stylesheet">
		<link href="/css/three-cards-style.css" rel="stylesheet">

		<meta name="robots" contect= "all">
		<meta name="description" contect="一个热爱学习的 Java 程序员,喜欢 Vue,喜欢深度学习">
		<!-- 主页使用 category作为 keywords,文章页使用文章的 keywords -->
		
		<meta name="keywords" contect="java,synchronized,AtomicInteger,ReentrantLock,ReentrantReadWriteLock,LockSupport,Condition,CountDownLatch,CyclicBarrier,Semaphore,Phaser,Fork/Join,Exchanger,FutureTask">
		 
		<link rel="icon shortcut" type="image/ico" href=/images/favicon.jpg>
		<title>
			U2647's blog
		</title>
		<!-- 百度统计 -->
		
		<!-- Google Search Console -->
		
	<meta name="generator" content="Hexo 6.3.0"></head>
	<body>
		<div id="app">
			<v-app>
				<!-- 页头 -->
				<v-card tile elevation="24"  style="width: 80%; margin: 0 auto; text-align:center; background:rgba(0,0,0,0); margin-bottom: 3%;" gradient="to bottom, rgba(0,0,0,.1), rgba(0,0,0,.5)">
	<v-img height="240" src="" class="white--text align-end" >
		<v-card-title style="text-align: left; margin-left: 0.3%;">U2647's blog</v-card-title>
		<v-card-text style="text-align: left;margin-left: 0.3%;" class="white--text">
			一个热爱学习的 Java 程序员,喜欢 Vue,喜欢深度学习
		</v-card-text>
		<v-divider style="margin-left: 1.3%; margin-right: 1.3%;" class="success lighten-1"></v-divider>
		<v-card-text style="text-align: left;" class="white--text">
			
					
					<v-btn text class="white--text" style="text-transform:capitalize;" href="/categories/Dubbo">Dubbo</v-btn>
					
					<v-btn text class="white--text" style="text-transform:capitalize;" href="/categories/Flutter">Flutter</v-btn>
					
					<v-btn text class="white--text" style="text-transform:capitalize;" href="/categories/SpringBoot">SpringBoot</v-btn>
					
					<v-btn text class="white--text" style="text-transform:capitalize;" href="/categories/Debug">Debug</v-btn>
					
					<v-btn text class="white--text" style="text-transform:capitalize;" href="/categories/Notes">Notes</v-btn>
					
					<v-btn text class="white--text" style="text-transform:capitalize;" href="/categories/Java">Java</v-btn>
					
					<v-btn text class="white--text" style="text-transform:capitalize;" href="/categories/LeetCode">LeetCode</v-btn>
					
					<v-btn text class="white--text" style="text-transform:capitalize;" href="/categories/Python">Python</v-btn>
					
					<v-btn text class="white--text" style="text-transform:capitalize;" href="/categories/Redis">Redis</v-btn>
					
					<v-btn text class="white--text" style="text-transform:capitalize;" href="/categories/Android">Android</v-btn>
					
					<v-btn text class="white--text" style="text-transform:capitalize;" href="/categories/DesignPattern">DesignPattern</v-btn>
				
			
		</v-card-text>
	</v-img>
	<v-divider style="margin-left: 1.3%; margin-right: 1.3%;" class="success lighten-1"></v-divider>
	<v-card-actions >
		
			<v-btn text x-large class="white--text" style="margin-left: 0.5%;margin-top:0.5%;margin-bottom: 0.5%;" href=/>
				<v-icon right>
					mdi-home-outline
				</v-icon>
				首页
			</v-btn>
		
			<v-btn text x-large class="white--text" style="margin-left: 0.5%;margin-top:0.5%;margin-bottom: 0.5%;" href=/tags>
				<v-icon right>
					mdi-cloud-outline
				</v-icon>
				标签云
			</v-btn>
		
			<v-btn text x-large class="white--text" style="margin-left: 0.5%;margin-top:0.5%;margin-bottom: 0.5%;" href=/timeline>
				<v-icon right>
					mdi-timeline-text-outline
				</v-icon>
				时间轴
			</v-btn>
		
		<v-spacer></v-spacer>
		<v-btn text x-large class="white--text" style="margin-left: 0.5%;margin-top:0.5%;margin-bottom: 0.5%;">
			<v-icon right>
			mdi-draw-pen
			</v-icon>
			文章总数  
	  	</v-btn >
		<v-btn icon style="margin-right: 0.5%;margin-top:0.5%;margin-bottom: 0.5%;">
			<v-avatar color="success" size="35" >
				<span class="white--text"> 62 </span>
			</v-avatar>
		</v-btn>
	  </v-card-actions>
</v-card>
 
				<div style="width: 55%; margin: 0 auto; text-align:center;">
					<v-card tile max-width="100%" elevation="24" style="margin-bottom: 3%;" >
    <v-img height="240" class="white--text align-end" src=/random/material-12.jpg gradient="to bottom, rgba(0,0,0,.1), rgba(0,0,0,.5)">
        <v-card-title style="text-align: left;margin-left: 0.6%;">
            <span>Java J.U.C 学习笔记-使用篇（一）</span>
        </v-card-title>
    <v-card-text style="text-align: left;margin-left: 0.8%;">
        Java J.U.C 学习笔记-使用篇（一）
    </v-card-text>
    <v-divider class="success lighten-1" style="margin-left:2%; margin-right: 2%;"></v-divider>
    <v-card-actions style="text-align: left;" class="white--text" style="margin-left:2%; margin-right: 2%;">
        
            	
                <v-btn text class="white--text" style="text-transform:capitalize;margin-left:0.5%;">synchronized</v-btn>
            	
                <v-btn text class="white--text" style="text-transform:capitalize;margin-left:0.5%;">AtomicInteger</v-btn>
            	
                <v-btn text class="white--text" style="text-transform:capitalize;margin-left:0.5%;">ReentrantLock</v-btn>
            	
                <v-btn text class="white--text" style="text-transform:capitalize;margin-left:0.5%;">ReentrantReadWriteLock</v-btn>
            	
                <v-btn text class="white--text" style="text-transform:capitalize;margin-left:0.5%;">LockSupport</v-btn>
            	
                <v-btn text class="white--text" style="text-transform:capitalize;margin-left:0.5%;">Condition</v-btn>
            	
                <v-btn text class="white--text" style="text-transform:capitalize;margin-left:0.5%;">CountDownLatch</v-btn>
            	
                <v-btn text class="white--text" style="text-transform:capitalize;margin-left:0.5%;">CyclicBarrier</v-btn>
            	
                <v-btn text class="white--text" style="text-transform:capitalize;margin-left:0.5%;">Semaphore</v-btn>
            	
                <v-btn text class="white--text" style="text-transform:capitalize;margin-left:0.5%;">Phaser</v-btn>
            	
                <v-btn text class="white--text" style="text-transform:capitalize;margin-left:0.5%;">Fork/Join</v-btn>
            	
                <v-btn text class="white--text" style="text-transform:capitalize;margin-left:0.5%;">Exchanger</v-btn>
            	
                <v-btn text class="white--text" style="text-transform:capitalize;margin-left:0.5%;">FutureTask</v-btn>
            
        
        <v-spacer></v-spacer>
		<v-btn text class="white--text" >
			<v-icon right>
			mdi-cursor-default-click-outline
			</v-icon>
			点击量
	  	</v-btn >
		<v-btn icon >
			<v-avatar color="success" size="35" >
				<span id = "busuanzi_value_page_pv" class="white--text"> 62 </span>
			</v-avatar>
		</v-btn>
    </v-card-actions>
    </v-img>    
    <v-card-text>
        <div id = "post_container" class="text-justify" style="padding-left: 2%;padding-right: 2%;padding-bottom: 2%">
            <h1 id="Java-J-U-C-学习笔记-使用篇（一）"><a href="#Java-J-U-C-学习笔记-使用篇（一）" class="headerlink" title="Java J.U.C 学习笔记-使用篇（一）"></a>Java J.U.C 学习笔记-使用篇（一）</h1><p>一直想写一篇关于多线程的文章，但是迟迟没有动笔，主要是感觉自己掌握的还是不够牢固，怕写出的东西误人子弟，不过看了看自己博客的访问量，感觉这个担心是多余的了。小丑竟是我自己.jpg</p>
<p>Java 多线程如果根据使用场景分的话可以分为两类类。</p>
<ol>
<li>线程间的竞争。多个线程同时竞争一个资源。这个时候需要想办法保证，资源在同一时刻只能由一个线程操作。</li>
<li>线程间的通信。多个线程间需要通过信息传递。协同完成一件事情，这个时候要想办法处理线程间如何通信，如果交互。</li>
</ol>
<p>下面我会针对这两种情况分别说明。</p>
<h2 id="1-线程间的竞争"><a href="#1-线程间的竞争" class="headerlink" title="1. 线程间的竞争"></a>1. 线程间的竞争</h2><p>线程间的竞争是指，多个线程间同时需要访问一个资源，而这个资源如果不是<strong>线程安全</strong>的，那么就会出现不可预知的问题。比如下面这段常见的代码</p>
<pre><code class="java">        static int count = 0;
    public static void func1() throws InterruptedException &#123;
        Thread t1 = new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 10000; i++) &#123;
                count++;
            &#125;
        &#125;);
        Thread t2 = new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 10000; i++) &#123;
                count++;
            &#125;
        &#125;);

        t1.start();
        t2.start();

        //等待两个线程执行结束
        Thread.sleep(1000);
        System.out.println(count);
    &#125;
</code></pre>
<p>你会发现每次执行的结果可能都不一样，但是都会比 20000 小，这是因为 <code>count++</code> 并不是原子操作，t1 读到 count  &#x3D; A,时，t2 读取到的可能也是 count &#x3D; A，这个时候同时执行 <code>count++</code> 就会少加一次，某个线程的结果被另外一个线程覆盖掉。导致最终的结果小于 20000。</p>
<p>这个问题就是我们上文说的那样，多个线程同时竞争一个资源 count 的值。这个时候我们需要想办法保证 count 在同一个时刻只有一个线程访问。</p>
<h3 id="1-1-synchronized-关键字"><a href="#1-1-synchronized-关键字" class="headerlink" title="1.1 synchronized 关键字"></a>1.1 synchronized 关键字</h3><p>第一种办法是使用<strong>synchronized</strong>关键字，synchronize 关键字可以对代码进行自动加锁和解锁操作，保证同时只有一个线程操作。例如：</p>
<pre><code class="java">    static int count = 0;
    public static void func1() throws InterruptedException &#123;
        Object lock = new Object();
        Thread t1 = new Thread(() -&gt; &#123;
            synchronized (lock) &#123;
                for (int i = 0; i &lt; 10000; i++) &#123;
                    count++;
                &#125;
            &#125;
        &#125;);
        Thread t2 = new Thread(() -&gt; &#123;
            synchronized (lock) &#123;
                for (int i = 0; i &lt; 10000; i++) &#123;
                    count++;
                &#125;
            &#125;
        &#125;);

        t1.start();
        t2.start();
        //等待两个线程执行结束
        Thread.sleep(1000);
        System.out.println(count);
    &#125;
</code></pre>
<p>在 JDK1.6 之前，synchronize 关键字还是一个重量级的锁，底层是通过阻塞和唤醒机制实现的，所以需要操作系统切换CPU的执行状态，非常耗时。在 JDK1.6之后引入了偏向锁和轻量级锁后，synchronize 关键字的效率大大提高。</p>
<h3 id="1-2-原子类AtomicInteger"><a href="#1-2-原子类AtomicInteger" class="headerlink" title="1.2 原子类AtomicInteger"></a>1.2 原子类AtomicInteger</h3><p>synchronize 关键字是在操作上进行加锁控制，而原子类是在资源上进行控制，原子类内部可以保证只有一个线程访问该资源。例如：</p>
<pre><code class="java">
    static AtomicInteger atomicCount = new AtomicInteger(0);
    public static void func2() throws InterruptedException &#123;
        Thread t1 = new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 10000; i++) &#123;
                atomicCount.getAndAdd(1);
            &#125;

        &#125;);
        Thread t2 = new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 10000; i++) &#123;
                atomicCount.addAndGet(1);
            &#125;
        &#125;);

        t1.start();
        t2.start();

        //等待两个线程执行结束
        Thread.sleep(1000);
        System.out.println(atomicCount.get());
    &#125;
</code></pre>
<p>原子类的更新操作是使用的 CAS 指令。所以从性能上来说是要比 synchronize 高的。而且原子类也不止支持常见的基本类型，还支持数组（AtomicIntegerArray，AtomicLongArray，BooleanArray）和引用类型（AtomicReference，AtomicMarkedReference，AtomicStampedReference）。</p>
<h3 id="1-3-可重入锁-ReentrantLock"><a href="#1-3-可重入锁-ReentrantLock" class="headerlink" title="1.3  可重入锁 ReentrantLock"></a>1.3  可重入锁 ReentrantLock</h3><p>ReentrantLock 支持加锁和解锁两个操作，可以在适当的时候对操作进行加锁。作用的内容还是操作行为，不是资源。比如：</p>
<pre><code class="java">
    public static ReentrantLock reentrantLock = new ReentrantLock(true);
    public static void func4() throws InterruptedException &#123;
        Thread t1 = new Thread(() -&gt; &#123;
            reentrantLock.lock();
            for (int i = 0; i &lt; 10000; i++) &#123;
                count++;
            &#125;
            reentrantLock.unlock();

        &#125;);
        Thread t2 = new Thread(() -&gt; &#123;
            reentrantLock.lock();
            for (int i = 0; i &lt; 10000; i++) &#123;
                count++;
            &#125;
            reentrantLock.unlock();
        &#125;);

        t1.start();
        t2.start();

        //等待两个线程执行结束
        Thread.sleep(1000);
        System.out.println(count);
    &#125;
</code></pre>
<p>使用方式跟 synchronize 关键字很类似，区别是 synchronize 是自动的加锁和解锁，而 reentrantLock 是手动加锁操作的。构造参数支持公平和非公平锁。</p>
<h3 id="1-4-读写锁-ReentrantReadWriteLock"><a href="#1-4-读写锁-ReentrantReadWriteLock" class="headerlink" title="1.4 读写锁 ReentrantReadWriteLock"></a>1.4 读写锁 ReentrantReadWriteLock</h3><p>ReentrantReadWriteLock 内部有两个锁分别是 ReadLock（读锁） 和 WriteLock（写锁）。读锁可以被多个线程共享。写锁是只能有一个线程持有，而且读写锁是互斥的，就是说，如果有线程持有写锁，那么读锁是获取不到的（线程等待），同样如果有线程持有写锁，读锁也是获取不到的。例如：</p>
<pre><code class="java">
    static ReentrantReadWriteLock rrwLock = new ReentrantReadWriteLock();
    public static void func7()&#123;
        Thread t1 = new Thread(() -&gt; &#123;
            rrwLock.readLock().lock();
            System.out.println(&quot;t1 read lock&quot;);
            for (int i = 0; i &lt; 10000; i++) &#123;
                count++;
            &#125;
            rrwLock.readLock().unlock();
            System.out.println(&quot;t1 read unlock&quot;);
        &#125;);
        Thread t2 = new Thread(() -&gt; &#123;
            rrwLock.writeLock().lock();
            System.out.println(&quot;t2 write lock&quot;);
            for (int i = 0; i &lt; 10000; i++) &#123;
                count++;
            &#125;
            rrwLock.writeLock().unlock();
            System.out.println(&quot;t2 write unlock&quot;);
        &#125;);
        Thread t3 = new Thread(() -&gt; &#123;
            rrwLock.readLock().lock();
            System.out.println(&quot;t3 read lock&quot;);
            for (int i = 0; i &lt; 10000; i++) &#123;
                count++;
            &#125;
            rrwLock.readLock().unlock();
            System.out.println(&quot;t3 read unlock&quot;);
        &#125;);
        t1.start();
        t2.start();
        t3.start();
    &#125;

    public static void main(String[] args) throws Exception &#123;
        func7();
        Thread.sleep(1000);
        System.out.println(count);
    &#125;
</code></pre>
<p>以上面的代码为例，程序启动了 3 个线程，其中 t1、t3 是获取的读锁，可以同时执行，t2 获取的是写锁，不能与 t1、t3 同时执行，所以你看到的执行顺序可能是下面几种情况。</p>
<pre><code>t1 read lock
t3 read lock
t1 read unlock
t3 read unlock
t2 write lock
t2 write unlock
24523

t1、t3 同时执行，最后执行 t2,从这个执行结果我们也能够看到，count的值小于 30000 所以 t1、t2 是同时执行的。 

t1 read lock
t1 read unlock
t2 write lock
t2 write unlock
t3 read lock
t3 read unlock
30000

t1、t2、t3 顺序执行
</code></pre>
<p>也有可能是其他情况，但是，不管怎样执行，t2 线程一定是在无锁的情况下执行的。要么 t1、t3 线程还没有开始，要么就是已经执行结束了。</p>
<h2 id="2-线程间的通信"><a href="#2-线程间的通信" class="headerlink" title="2. 线程间的通信"></a>2. 线程间的通信</h2><p>线程间的通信主要是指线程间的<strong>等待-通知</strong>机制。A线程等待B线程执行，B线程执行到某个环节后，通知A线程继续执行。</p>
<h3 id="2-1-LockSupport"><a href="#2-1-LockSupport" class="headerlink" title="2.1 LockSupport"></a>2.1 LockSupport</h3><p>当调用<code>LockSupport.park()</code> 时，会阻塞方法，表示当前线程将进入等待状态。当调用<code>LockSupport.unpark(Thread thread)</code>时表示需要唤醒参数指定的线程。例如：</p>
<pre><code class="java">
    public static void func3(Thread thread) throws InterruptedException &#123;
        Thread t1 = new Thread(() -&gt; &#123;
            System.out.println(&quot;t1,run&quot;);
            LockSupport.park(&quot;t1&quot;);
            for (int i = 0; i &lt; 10000; i++) &#123;
                count++;
            &#125;
            System.out.println(&quot;t1 park &quot; + LockSupport.getBlocker(thread).toString());
            LockSupport.unpark(thread);
            System.out.println(&quot;t1,run end&quot;);
        &#125;);
        Thread t2 = new Thread(() -&gt; &#123;
            System.out.println(&quot;t2,run&quot;);
            LockSupport.park(&quot;t2&quot;);
            for (int i = 0; i &lt; 10000; i++) &#123;
                count++;
            &#125;
            System.out.println(&quot;t2 park &quot; + LockSupport.getBlocker(t1).toString());
            LockSupport.unpark(t1);
            System.out.println(&quot;t2,run end&quot;);

        &#125;);
        Thread t3 = new Thread(() -&gt; &#123;
            System.out.println(&quot;t3,run&quot;);
            for (int i = 0; i &lt; 10000; i++) &#123;
                count++;
            &#125;
            System.out.println(&quot;t3 park &quot; + LockSupport.getBlocker(t2).toString());
            LockSupport.unpark(t2);
            System.out.println(&quot;t3,run end&quot;);

        &#125;);
        t1.start();
        t2.start();
        t3.start();
    &#125;
    
    public static void main(String[] args) throws Exception &#123;
        func3(Thread.currentThread());
        LockSupport.park(&quot;main&quot;);
        System.out.println(count);
        System.out.println(&quot;main,run end&quot;);

    &#125;
</code></pre>
<p>main 方法先执行，调用 func3 后进入等待状态，func3 开启了 3 个线程，t1 和 t2 如果先抢到执行权则直接 park 进入等待状态，t3 先执行，然后通知 t2，t2 执行结束后通知 t1，最后 t1 通知主线程。至于 park 函数的参数，主要是用于打印日志，接入监控等后期排查问题使用的。LockSupport  还有另外一个方法<strong>parkNanos(Object blocker, long nanos)</strong> 支持等待时长配置，等待 nanos 秒之后，继续执行。</p>
<p>LockSupport 的 park 函数和 unpark 函数与 Java 中的 wait 和 notify 函数非常类似。与 wait-notify 方法的区别是 wait 方法必须先调用，然后再调用 notify，反过来的的话将一直无法唤醒等待的线程。而 park 和 unpark 则没有这个问题。但是，如果在调用 unpark 时，对应的线程还没有启动，则有可能出现线程无法唤醒的问题。比如，我们将启动顺序做如下修改：</p>
<pre><code class="java">        t3.start();
        Thread.sleep(100);
        t1.start();
        t2.start();
</code></pre>
<p>这个时候则会出现线程 t1、t2 一直等待的情况。</p>
<h3 id="2-2-ReentrantLock-的-Condition"><a href="#2-2-ReentrantLock-的-Condition" class="headerlink" title="2.2 ReentrantLock 的 Condition"></a>2.2 ReentrantLock 的 Condition</h3><p>ReentrantLock 的 Condition 对象也支持线程间等待通知机制。</p>
<pre><code>    static ReentrantLock reentrantLock = new ReentrantLock(true);
    static Condition c1 = reentrantLock.newCondition();
    static Condition c2 = reentrantLock.newCondition();

    public static void func5() throws Exception &#123;
        Thread t1 = new Thread(() -&gt; &#123;
            reentrantLock.lock();
            System.out.println(&quot;t1,run&quot;);
            try &#123;
                c1.await();
            &#125; catch (InterruptedException e) &#123;
                System.out.println(&quot;error&quot;);
            &#125;
            for (int i = 0; i &lt; 10000; i++) &#123;
                count++;
            &#125;
            reentrantLock.unlock();
            System.out.println(&quot;t1,run end&quot;);
        &#125;);
        Thread t2 = new Thread(() -&gt; &#123;
            reentrantLock.lock();
            System.out.println(&quot;t2,run&quot;);
            try &#123;
                c2.await();
            &#125; catch (InterruptedException e) &#123;
                System.out.println(&quot;error&quot;);
            &#125;
            for (int i = 0; i &lt; 10000; i++) &#123;
                count++;
            &#125;
            c1.signal();
            reentrantLock.unlock();
            System.out.println(&quot;t2,run end&quot;);
        &#125;);
        Thread t3 = new Thread(() -&gt; &#123;
            reentrantLock.lock();
            System.out.println(&quot;t3,run&quot;);
            for (int i = 0; i &lt; 10000; i++) &#123;
                count++;
            &#125;
            c2.signal();
            reentrantLock.unlock();
            System.out.println(&quot;t3,run end&quot;);
        &#125;);
        t1.start();
        t2.start();
        t3.start();
    &#125;
</code></pre>
<p>func5 创建了三个线程，其中 t1、t2 线程如果先抢到执行权的话会进入等待状态，t3 先执行。然后通知 t2，t2 再通知 t1。需要注意的是，await 和 signal 方法必须在 lock 和 unlock 之间调用。因为  Condition 对象是强依赖 ReentrantLock 的。await 和 signal 底层也是 LockSupport  实现的，所以 await 和 signal 的调用顺序是不会造成死锁的，唯一需要注意的也是，调用 signal 时要保证线程是存活的。</p>
<h3 id="2-3-同步计数器-CountDownLatch"><a href="#2-3-同步计数器-CountDownLatch" class="headerlink" title="2.3 同步计数器 CountDownLatch"></a>2.3 同步计数器 CountDownLatch</h3><p>CountDownLatch 是一个计数器工具类，构造方法必须传入一个大于 0 的整型值。而每调用一次 countDown() 方法 这个值就会减一。CountDownLatch 的 await() 方法会一直等待到这个值为 0 后才会继续执行。CountDownLatch 工具有点类似于 join 方法。主要功能就是等待 N 个线程全部执行完之后，某个线程才会继续执行。代码如下：</p>
<pre><code class="java">
    static CountDownLatch downLatch = new CountDownLatch(3);
    public static void func8()&#123;
        Thread t1 = new Thread(() -&gt; &#123;
            System.out.println(&quot;t1 run&quot;);
            downLatch.countDown();
            System.out.println(&quot;t1 run end&quot;);
        &#125;);
        Thread t2 = new Thread(() -&gt; &#123;
            System.out.println(&quot;t2 run&quot;);
            downLatch.countDown();
            System.out.println(&quot;t2 run end&quot;);
        &#125;);
        Thread t3 = new Thread(() -&gt; &#123;
            System.out.println(&quot;t3 run&quot;);
            downLatch.countDown();
            System.out.println(&quot;t3 run end&quot;);
        &#125;);
        t1.start();
        t2.start();
        t3.start();
    &#125;
    public static void main(String[] args) throws Exception &#123;
        func8();
        downLatch.await();
        System.out.println(&quot;main end&quot;);
    &#125;
</code></pre>
<p>三个线程同时执行，每一个线程执行一次 countDown()  初始值就会减一，直到为 0 ，主线程继续执行。</p>
<h3 id="2-4-栅栏-CyclicBarrier"><a href="#2-4-栅栏-CyclicBarrier" class="headerlink" title="2.4 栅栏 CyclicBarrier"></a>2.4 栅栏 CyclicBarrier</h3><p>与计数器的区别是，CyclicBarrier 的作用是，等待 N 个线程同时执行到某个节点（栅栏）后，N 个线程同时开始执行。举个简单的例子，王者荣耀在进入游戏时，10个用户线程需要等待服务器的资源全部准备完成后才同时进入到游戏页面。这个时候就可以使用 CyclicBarrier。而且 CyclicBarrier 可以重用。例如：</p>
<pre><code class="java">    static CyclicBarrier cyclicBarrier = new CyclicBarrier(3, new Runnable() &#123;
        @Override
        public void run() &#123;
            System.out.println(&quot;cyclicBarrier run &quot;);
        &#125;
    &#125;);
    public static void func9()&#123;
        Thread t1 = new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 10; i++) &#123;
                System.out.println(&quot;t1 run&quot;+i);
                try &#123;
                    cyclicBarrier.await();
                &#125; catch (InterruptedException | BrokenBarrierException e) &#123;
                    e.printStackTrace();
                &#125;
                System.out.println(&quot;t1 run end&quot;+i);
            &#125;
        &#125;);
        Thread t2 = new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 10; i++) &#123;
                System.out.println(&quot;t2 run&quot;+i);
                try &#123;
                    cyclicBarrier.await();
                &#125; catch (InterruptedException | BrokenBarrierException e) &#123;
                    e.printStackTrace();
                &#125;
                System.out.println(&quot;t2 run end&quot;+i);
            &#125;
        &#125;);
        Thread t3 = new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 10; i++) &#123;
                System.out.println(&quot;t3 run&quot;+i);
                try &#123;
                    cyclicBarrier.await();
                &#125; catch (InterruptedException | BrokenBarrierException e) &#123;
                    e.printStackTrace();
                &#125;
                System.out.println(&quot;t3 run end&quot;+i);
            &#125;
        &#125;);
        t1.start();
        t2.start();
        t3.start();
    &#125;

    public static void main(String[] args) throws Exception &#123;
        func9();
    &#125;
</code></pre>
<p>代码开启了 3 个线程，每一个线程都会循环 10 次。方法的执行结果一定是每个线程的第 i 次循环依次执行的，如果某个线程先执行到第 i 次循环，那么就会等待另外两个线程。直到另外两个线程也循环到 i，才会继续执行。CyclicBarrier 的构造方法 第一个参数是需要等待的线程数量。N 个线程同时开始运行，先到终点的线程需要等他其他线程到达终点后才能继续同时跑第二圈。与 CountDownLatch 相比的另外一个区别是 CyclicBarrier 支持循环使用，栅栏破坏后，还能继续循环使用。而且可以使用 <code>reset()</code> 可以手动重置。也可以调用<code>getNumberWaiting()</code> 方法获取当前在等待的线程数量。 </p>
<h3 id="2-5-信号量-Semaphore"><a href="#2-5-信号量-Semaphore" class="headerlink" title="2.5 信号量 Semaphore"></a>2.5 信号量 Semaphore</h3><p>Semaphore称为计数信号量，它允许n个任务同时访问某个资源，可以将信号量看做是在向外分发使用资源的许可证，只有成功获取许可证，才能使用资源。</p>
<pre><code class="java">
    public static Semaphore semaphore = new Semaphore(1);
    public static void func10()&#123;
        Thread t1 = new Thread(() -&gt; &#123;
            try &#123;
                semaphore.acquire();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            System.out.println(&quot;t1 run&quot;);
            for (int i = 0; i &lt; 10000; i++) &#123;
                count++;
            &#125;
            System.out.println(&quot;t1 run end&quot;);
            semaphore.release();
        &#125;);
        Thread t2 = new Thread(() -&gt; &#123;
            try &#123;
                semaphore.acquire();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            System.out.println(&quot;t2 run&quot;);
            for (int i = 0; i &lt; 10000; i++) &#123;
                count++;
            &#125;
            System.out.println(&quot;t2 run end&quot;);
            semaphore.release();
        &#125;);
        Thread t3 = new Thread(() -&gt; &#123;
            try &#123;
                semaphore.acquire();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            System.out.println(&quot;t3 run&quot;);
            for (int i = 0; i &lt; 10000; i++) &#123;
                count++;
            &#125;
            System.out.println(&quot;t3 run end&quot;);
            semaphore.release();
        &#125;);
        t1.start();
        t2.start();
        t3.start();
    &#125;
</code></pre>
<p>信号量的初始化函数需要传入可用的令牌数量，每次调用<code>acquire()</code> 方法来获取一个令牌，如果当前没有可用到的令牌就会一直等待下去，直到有可用的令牌或者线程被中断。 调用<code>release()</code> 方法会释放一个令牌。这里需要注意的是，release 方法会增加令牌数量，每调用一次就会增加一个令牌，甚至在某些情况下回超过初始化设置的值。</p>
<h3 id="2-6-阶段器-Phaser"><a href="#2-6-阶段器-Phaser" class="headerlink" title="2.6 阶段器 Phaser"></a>2.6 阶段器 Phaser</h3><p>Phaser 是 JDK1.7 新增的一个工具类。功能类似于 CountDownLatch 和 CyclicBarrier 组合。协调多个线程到达某个时间点后同时开始执行（类似于CountDownLatch）。这个过程可以重复执行（类似于CyclicBarrier）。不同的是，Phaser支持在运行期间增加或者减少参与的线程数量。</p>
<p>CyclicBarrier 有栅栏的概念，而在 Phaser 中栅栏被称作<strong>阶段（phase）</strong> 当所有参与者都达到当前阶段后，阶段或自动递增。同时所有线程同时开始执行。</p>
<pre><code class="java">
    public static Phaser phaser = new Phaser(3)&#123;
        @Override
        protected boolean onAdvance(int phase, int registeredParties) &#123;
            System.out.println(&quot;phase:&quot; + phase + &quot;,registeredParties:&quot; + registeredParties);
            return super.onAdvance(phase, registeredParties);
        &#125;
    &#125;;

    public static void func11()&#123;
        Thread t1 = new Thread(() -&gt; &#123;
            System.out.println(&quot;t1 run&quot;);
            for (int i = 0; i &lt; 10000; i++) &#123;
                phaser.arriveAndAwaitAdvance();
                count++;
                System.out.println(&quot;t1:&quot; + i);
            &#125;
            System.out.println(&quot;t1 run end&quot;);
            phaser.arriveAndDeregister();
        &#125;);
        Thread t2 = new Thread(() -&gt; &#123;
            System.out.println(&quot;t2 run&quot;);
            for (int i = 0; i &lt; 10000; i++) &#123;
                phaser.arriveAndAwaitAdvance();
                count++;
                System.out.println(&quot;t2:&quot; + i);
            &#125;
            System.out.println(&quot;t2 run end&quot;);
            phaser.arriveAndDeregister();
        &#125;);
        Thread t3 = new Thread(() -&gt; &#123;
            System.out.println(&quot;t3 run&quot;);
            for (int i = 0; i &lt; 10000; i++) &#123;
                phaser.arriveAndAwaitAdvance();
                count++;
                System.out.println(&quot;t3:&quot; + i);
            &#125;
            System.out.println(&quot;t3 run end&quot;);
            phaser.arriveAndDeregister();
        &#125;);
        t1.start();
        t2.start();
        t3.start();
    &#125;
</code></pre>
<p>初始化时可以指定参与线程的个数。执行期间也可以通过 <code>register()</code> 方法增加线程个数。而 <code>arriveAndAwaitAdvance()</code> 方法是等待方法，所有线程执行到该方法后，才会继续执行。<code>arriveAndDeregister()</code> 方法的作用是减少参与线程的个数。构造方法支持重写 <code>onAdvance()</code> 方法，该方法每次所有线程到达某一个阶段时执行一次。类似于 CyclicBarrier 的 Runnable 参数。</p>
<p>PS：代码里的 phaser 只能保证每个线程的第 i 次循环执行后才会同时执行下一次，但是并不能保证 count 的值是正确的，因为每次循环都是 3 个线程在同时进行 +1 操作，最终的值也一定是不准确的。</p>
<h2 id="3-线程间的数据交互"><a href="#3-线程间的数据交互" class="headerlink" title="3. 线程间的数据交互"></a>3. 线程间的数据交互</h2><p>上面的线程间的通信其实更偏向于线程间的协调。协调多个线程同时处理一个任务。而在某些场景下我们需要知道其他线程的执行结果。这个时候就需要在多线程之间进行数据的交互了。</p>
<h3 id="3-1-Fork-x2F-Join-框架"><a href="#3-1-Fork-x2F-Join-框架" class="headerlink" title="3.1 Fork&#x2F;Join 框架"></a>3.1 Fork&#x2F;Join 框架</h3><p>fork&#x2F;join 框架是 JDK1.7 新增的工具类，它是分治算法的并行实现。ForkJoinTask 常用的子类有三个：</p>
<ul>
<li>RecursiveTask ：执行任务并返回结果</li>
<li>RecursiveAction：无返回值</li>
<li>CountedCompleter：任务执行结束后，会触发一个自定义函数。并且可以获取任务执行的结果。</li>
</ul>
<pre><code class="java">    public static void func12()&#123;
        List&lt;RecursiveTask&lt;Integer&gt;&gt; tasks = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 3; i++) &#123;
            int finalI = i;
            RecursiveTask&lt;Integer&gt; recursiveTask = new RecursiveTask&lt;Integer&gt;() &#123;
                @Override
                protected Integer compute() &#123;
                    if (finalI % 2 == 0) &#123;
                        throw new NullPointerException(&quot;sssssss&quot;);
                    &#125;
                    System.out.println(finalI + &quot; run&quot;);
                    int total = 0;
                    for (int i = 0; i &lt; 10000; i++) &#123;
                        total++;
                    &#125;
                    return total;
                &#125;
            &#125;;
            tasks.add(recursiveTask);
            recursiveTask.fork();
        &#125;
        for (RecursiveTask&lt;Integer&gt; task : tasks) &#123;
            try &#123;
                System.out.println(&quot;join:&quot;+task.join());
            &#125; catch (Exception e) &#123;
                System.out.println(e);
            &#125;
            System.out.println(&quot;getRawResult:&quot; + task.getRawResult());
        &#125;
    &#125;

    public static void func13()&#123;
        List&lt;RecursiveAction&gt; tasks = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 3; i++) &#123;
            int finalI = i;
            RecursiveAction recursiveTask = new RecursiveAction() &#123;
                @Override
                protected void compute() &#123;
                    System.out.println(finalI + &quot; run&quot;);
                &#125;
            &#125;;
            recursiveTask.fork();
        &#125;
    &#125;

    public static void func14() &#123;
        List&lt;CountedCompleter&lt;Integer&gt;&gt; tasks = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 3; i++) &#123;
            int finalI = i;
            CountedCompleter&lt;Integer&gt; countedCompleter = new CountedCompleter&lt;Integer&gt;() &#123;
                int total = 0;
                @Override
                public void compute() &#123;
                    System.out.println(finalI + &quot; run&quot;);
                    for (int i = 0; i &lt; 10000; i++) &#123;
                        total++;
                    &#125;
                    tryComplete();
                &#125;
                @Override
                public void onCompletion(CountedCompleter&lt;?&gt; caller) &#123;
                    System.out.println(&quot;onCompletion run!&quot; + finalI + &quot;，total：&quot; + total);
                &#125;

                @Override
                public Integer getRawResult() &#123;
                    return total;
                &#125;
            &#125;;
            tasks.add(countedCompleter);
            countedCompleter.fork();
        &#125;
        for (CountedCompleter&lt;Integer&gt; task : tasks) &#123;
            task.join();
            System.out.println(task.getRawResult());
        &#125;
        System.out.println(&quot;func end!&quot;);
    &#125;
</code></pre>
<p>fork 函数将启动线程开始执行。join 将等待线程执行结束，并返回结果。如果线程内部有异常抛出，则可以在 join 方法处捕获到，而 getRawResult 函数则是获取执行结果，并不会等待线程执行结束，如果直接调用 getRawResult 则有可能获取到的是执行到一半的结果。所以在调用 getRawResult 之前一定要先调用 join 方法。</p>
<p>对于 CountedCompleter 类来说，compute 执行结束后，会自动执行 onCompletion 方法。可以将一些任务执行完成的逻辑放到这个函数里。同样也是可以通过 join 和 getRawResult  方法获取执行结果，不过需要自己实现 getRawResult 方法的逻辑。</p>
<p><strong>PS: compute 方法内，需要手动调用 tryComplete 函数，不然 join 将会一直等待，程序无法正常结束！</strong></p>
<h3 id="3-2-交换工具类-Exchanger"><a href="#3-2-交换工具类-Exchanger" class="headerlink" title="3.2 交换工具类 Exchanger"></a>3.2 交换工具类 Exchanger</h3><p>Exchanger 主要是用来在<strong>两个线程</strong>间进行数据交换的工具类。它可以在某个时间点等待另外一个线程进行交换数据的动作。</p>
<pre><code class="java">
    public static void func15()&#123;
        Exchanger&lt;Integer&gt; exchanger = new Exchanger&lt;&gt;();
        Thread t1 = new Thread(() -&gt; &#123;
            System.out.println(&quot;t1 run&quot;);
            int num = 0;
            for (int i = 0; i &lt; 10000; i++) &#123;
                num++;
            &#125;
            try &#123;
                count = exchanger.exchange(num) + num;
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            System.out.println(&quot;t1 run end&quot;);
        &#125;);
        Thread t2 = new Thread(() -&gt; &#123;
            System.out.println(&quot;t2 run&quot;);
            int num = 0;
            for (int i = 0; i &lt; 10000; i++) &#123;
                num++;
            &#125;
            try &#123;
                count = exchanger.exchange(num) + num;
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            System.out.println(&quot;t2 run end&quot;);
        &#125;);
        t1.start();
        t2.start();
    &#125;
</code></pre>
<p><code>exchange</code> 方法会同步等待另外一个线程进行数据交换。需要注意的是，交换数据一定是两两交换，所以使用 Exchanger 的线程一定要是双数，不然就会有一个线程一直在等待交换，无法结束。</p>
<h3 id="3-3-FutureTask"><a href="#3-3-FutureTask" class="headerlink" title="3.3 FutureTask"></a>3.3 FutureTask</h3><p>FutureTask 可以通过 get 方法来获取线程的执行结果。是开发中比较常用的一个工具类。基本上可以支持大部分场景。</p>
<pre><code class="java">    public static void func16() throws ExecutionException, InterruptedException &#123;
        List&lt;FutureTask&lt;Integer&gt;&gt; tasks = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 3; i++) &#123;
            FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(new Callable&lt;Integer&gt;() &#123;
                @Override
                public Integer call() throws Exception &#123;
                    int num = 0;
                    for (int j = 0; j &lt; 100; j++) &#123;
                        num++;
                    &#125;
                    return num;
                &#125;
            &#125;);
            tasks.add(task);
            task.run();
        &#125;
        for (FutureTask&lt;Integer&gt; task : tasks) &#123;
            System.out.println(task.get());
        &#125;
    &#125;
</code></pre>
<p><code>tast.get()</code> 方法会等待线程的执行结果。而且可以从该方法中捕获线程内部抛出的异常。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>以上就是 JDK 提供的一些多线程的工具类，其实Java多线程并没有想象中的那么难，无非就是线程竞争要<strong>加锁</strong>，常用的就是synchronized和ReentrantLock。线程通信的话就是<strong>等待-通知</strong>机制，常用的就是 CountDownLatch和CyclicBarrier，如果要获取线程的执行结果就直接FutureTask。</p>

        </div>
    </v-card-text>
    <v-divider class="success lighten-1" ></v-divider>
    <v-card-text>
        <v-alert style="margin-left:2%; margin-right: 2%;padding-top: 2%;padding-bottom: 2%;" dense text border="left" type="success">
            版权声明：本博客所有文章除特别声明外，均采用 <a href="/creativecommons.html" target="_blank">CC BY-NC-SA 4.0 </a>许可协议。转载请注明出处！
        </v-alert>
    </v-card-text>
</v-card>
  
					<!-- 分页 -->
					
				</div>
				<!-- 页脚 -->
				<div style="width: 100%; margin-top: 2%; text-align:center;">
	<v-footer padless style="background:rgba(76,175,80,0.4);">
    <v-card style="width: 100%; text-align:center;background:rgba(0,0,0,0);" gradient="to top, rgba(0,0,0,.2), rgba(0,0,0,.8)" tile elevation="24" class="white--text text-center">
      <v-card-actions style="text-align: center;">
		
			<v-chip  class="white--text" style="background:rgba(0,0,0,0);" href=https://github.com/zdRan>
				我的GitHub
			</v-chip>
		
			<v-chip  class="white--text" style="background:rgba(0,0,0,0);" href=https://leetcode.cn/u/u2647>
				我的LeetCode
			</v-chip>
		
			<v-chip  class="white--text" style="background:rgba(0,0,0,0);" href=https://juejin.cn/user/3896324938793943>
				我的掘金
			</v-chip>
		
		<v-spacer></v-spacer>
		<div>
			<v-list-item two-line>
				<!-- 很高兴您使用本主题，开发不易，希望您保留一下版权声明，它并不会影响页面效果 ~ -->
				<v-list-item-content style="text-align: left;display: inline-block;">
					<v-list-item-subtitle class="white--text">Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="color: white;"><strong>Hexo</strong></a></v-list-item-subtitle>
					<v-list-item-subtitle class="white--text">Powered by <a target="_blank" rel="noopener" href="https://github.com/zdRan/three-cards" style="color: white;"><strong>three-cards</strong></a></v-list-item-subtitle>
				</v-list-item-content>
			</v-list-item>
		</div>
      </v-card-actions>
      <v-divider class="success lighten-1"></v-divider>
      <v-card-text class="white--text">
    	Copyright © 2017 - {{ new Date().getFullYear() }}  <a target="_blank" href="http://www.miitbeian.gov.cn" rel="nofollow noopener" style="color: white;">某ICP备xxxxxxxx号</a>
      </v-card-text>
    </v-card>
  </v-footer>
</div> 
			</v-app>			
		</div>
        <script>
        	new Vue({
            	el: '#app',
            	vuetify: new Vuetify(),
          	});
			//加载代码高亮
			hljs.highlightAll();
        </script>
    </body>
</html>